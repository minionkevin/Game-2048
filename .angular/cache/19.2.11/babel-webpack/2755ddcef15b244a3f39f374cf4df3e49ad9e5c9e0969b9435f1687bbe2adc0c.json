{"ast":null,"code":"import { PLATFORM_ID } from '@angular/core';\nimport { Int2 } from '../block-pos.Module';\nimport { Subject } from 'rxjs';\nimport { isPlatformBrowser } from '@angular/common';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./user.service\";\nimport * as i3 from \"./score.service\";\nexport let BoardService = /*#__PURE__*/(() => {\n  class BoardService {\n    http;\n    userService;\n    scoreService;\n    platformId;\n    constructor(http, userService, scoreService, platformId) {\n      this.http = http;\n      this.userService = userService;\n      this.scoreService = scoreService;\n      this.platformId = platformId;\n    }\n    gameOverEvent = new Subject();\n    gameOver$ = this.gameOverEvent.asObservable();\n    isGameOver = false;\n    row = 4;\n    column = 4;\n    getBoardSize() {\n      return this.row * this.column;\n    }\n    blockPosData = new Array(16).fill(null).map((_, index) => ({\n      value: 0,\n      index: -1,\n      pos2d: new Int2(-1, -1),\n      xPos: 0,\n      yPos: 0,\n      shouldShow: false,\n      isMerge: false\n    }));\n    blockData = [];\n    // init board data\n    initGame() {\n      for (let i = 0; i < this.blockPosData.length; i++) {\n        this.blockPosData[i] = {\n          value: 0,\n          index: i,\n          pos2d: Int2.convertToInt2Pos(i),\n          xPos: this.getTop(i),\n          yPos: this.getLeft(i),\n          shouldShow: false,\n          isMerge: false\n        };\n      }\n      this.blockData = this.getInitialBlockData();\n      this.addRandomBlock();\n      this.addRandomBlock();\n    }\n    getInitialBlockData() {\n      return new Array(16).fill(null).map(() => ({\n        value: 0,\n        index: -1,\n        pos2d: new Int2(-1, -1),\n        xPos: 0,\n        yPos: 0,\n        shouldShow: false,\n        isMerge: false\n      }));\n    }\n    // Add block to random avaiable on the board\n    addRandomBlock() {\n      const emptyIndices = [];\n      this.blockData.forEach((block, i) => {\n        if (block.index === -1) {\n          emptyIndices.push(i);\n        }\n        if (block.value > this.scoreService.getCurrHighScore()) {\n          const num = block.value;\n          this.scoreService.setCurrHighScore(num);\n          if (isPlatformBrowser(this.platformId)) localStorage.setItem('highestScore', num.toString());\n        }\n      });\n      if (emptyIndices.length === 0) {\n        this.setBoardState(true);\n        this.gameOverEvent.next();\n        return;\n      }\n      const randomIndex = emptyIndices[Math.floor(Math.random() * emptyIndices.length)];\n      // calculate position\n      this.blockData[randomIndex] = {\n        value: Math.random() < 0.75 ? 2 : 4,\n        index: randomIndex,\n        pos2d: Int2.convertToInt2Pos(randomIndex),\n        xPos: this.getTop(randomIndex),\n        yPos: this.getLeft(randomIndex),\n        shouldShow: true,\n        isMerge: false\n      };\n    }\n    // take player input and move to direction\n    moveBlocks(direction) {\n      this.blockData.forEach(block => {\n        block.isMerge = false;\n      });\n      this.moveInDirection(direction);\n      this.addRandomBlock();\n      this.savePlayerState();\n    }\n    // change board data and move blocks depends on direction\n    moveInDirection(direction) {\n      const isHorizontal = direction === 'left' || direction === 'right';\n      const outerRange = [0, 1, 2, 3];\n      const innerRange = direction === 'left' || direction === 'up' ? [0, 1, 2, 3] : [3, 2, 1, 0];\n      for (let outer of outerRange) {\n        for (let inner of innerRange) {\n          const x = isHorizontal ? inner : outer;\n          const y = isHorizontal ? outer : inner;\n          const currIndex = Int2.convertToIndexPosFromNum(x, y);\n          let currBlock = this.blockData[currIndex];\n          if (currBlock.value === 0) continue;\n          let currX = x;\n          let currY = y;\n          while (true) {\n            const nextX = currX + (direction === 'left' ? -1 : direction === 'right' ? 1 : 0);\n            const nextY = currY + (direction === 'up' ? -1 : direction === 'down' ? 1 : 0);\n            if (nextX < 0 || nextX >= this.row || nextY < 0 || nextY >= this.column) break;\n            const nextPos = new Int2(nextX, nextY);\n            const nextIndex = Int2.convertToIndexPosFromInt2(nextPos);\n            const nextBlock = this.blockData[nextIndex];\n            if (nextBlock.value === 0) {\n              this.moveBlockToBlankPos(currBlock, nextIndex);\n              currX = nextX;\n              currY = nextY;\n              currBlock = this.blockData[nextIndex];\n            } else if (nextBlock.value === currBlock.value && !nextBlock.isMerge && !currBlock.isMerge) {\n              this.swapBlockToBlockPos(currBlock, nextBlock);\n              this.cleanBlockPos(nextBlock, false);\n              currX = nextX;\n              currY = nextY;\n              currBlock = this.blockData[nextIndex];\n            } else {\n              break;\n            }\n          }\n        }\n      }\n    }\n    // move block to empty position\n    moveBlockToBlankPos(currBlock, newIndex) {\n      const removeIndex = currBlock.index;\n      let newBlock = {\n        value: currBlock.value,\n        index: newIndex,\n        pos2d: this.blockPosData[newIndex].pos2d,\n        xPos: this.blockPosData[newIndex].xPos,\n        yPos: this.blockPosData[newIndex].yPos,\n        isMerge: false,\n        shouldShow: true\n      };\n      this.cleanBlockPos(this.blockData[removeIndex], false);\n      this.blockData[newIndex] = newBlock;\n    }\n    // merge 2 same value blocks\n    swapBlockToBlockPos(currBlock, targetBlock) {\n      currBlock.isMerge = true;\n      currBlock.value *= 2;\n      currBlock.pos2d = targetBlock.pos2d;\n      currBlock.xPos = targetBlock.xPos;\n      currBlock.yPos = targetBlock.yPos;\n      const tempBlock = targetBlock;\n      const tempCurrIndex = currBlock.index;\n      const tempTargetIndex = targetBlock.index;\n      this.blockData[targetBlock.index] = currBlock;\n      this.blockData[tempCurrIndex] = tempBlock;\n      currBlock.index = tempTargetIndex;\n    }\n    // clean up block after moving\n    cleanBlockPos(targetBlock, isMerge) {\n      targetBlock.value = 0, targetBlock.index = -1, targetBlock.pos2d = new Int2(-1, -1), targetBlock.xPos = 0, targetBlock.yPos = 0, targetBlock.shouldShow = false, targetBlock.isMerge = isMerge;\n    }\n    // DEBUG: add value block to index position\n    addBlockToPos(debugIndex, debugValue) {\n      if (debugIndex > 15 || debugIndex < 0) return;\n      this.blockData[debugIndex] = {\n        value: this.isPowerOfTwo(debugValue) ? debugValue : 2,\n        index: debugIndex,\n        pos2d: Int2.convertToInt2Pos(debugIndex),\n        xPos: this.getTop(debugIndex),\n        yPos: this.getLeft(debugIndex),\n        shouldShow: true,\n        isMerge: false\n      };\n    }\n    // save player current board to database\n    savePlayerState() {\n      if (!this.userService.getUsername() || !isPlatformBrowser(this.platformId)) return;\n      const playerId = Number(localStorage.getItem('playerId'));\n      let data = [];\n      for (let i = 0; i < this.blockData.length; i++) {\n        data.push({\n          value: this.blockData[i].value,\n          index: this.blockData[i].index\n        });\n      }\n      const info = JSON.stringify({\n        data\n      });\n      const payload = {\n        playerId,\n        info\n      };\n      return this.http.post('${environment.apiUrl}/player-state', payload).subscribe({\n        next: response => {\n          // console.log('Move response:', response);\n        },\n        error: error => {\n          console.error('Move failed:', error);\n        }\n      });\n    }\n    // load player board from database by playerId\n    loadPlayerState(playerId) {\n      return this.http.get(`http://two048-back-0453.onrender.com/player-state/${playerId}`).subscribe({\n        next: response => {\n          const info = response.info;\n          for (let i = 0; i < info.data.length; i++) {\n            this.blockData[i] = this.handleSpawnBlockToIndex(info.data[i].index, info.data[i].value);\n          }\n        },\n        error: error => {\n          console.error('load failed:', error);\n        }\n      });\n    }\n    // spawn block to index position\n    handleSpawnBlockToIndex(blockIndex, blockValue) {\n      return {\n        value: blockValue,\n        index: blockIndex,\n        pos2d: Int2.convertToInt2Pos(blockIndex),\n        xPos: this.getTop(blockIndex),\n        yPos: this.getLeft(blockIndex),\n        shouldShow: true,\n        isMerge: false\n      };\n    }\n    restartGame() {\n      this.isGameOver = false;\n      this.initGame();\n      this.savePlayerState();\n    }\n    setBlockData(data) {\n      this.blockData = data;\n    }\n    isPowerOfTwo(n) {\n      return n > 0 && (n & n - 1) === 0;\n    }\n    getTop(index) {\n      return Math.floor(index / 4) * 110 + 10;\n    }\n    getLeft(index) {\n      return index % 4 * 110 + 10;\n    }\n    setBoardState(value) {\n      this.isGameOver = value;\n    }\n    getBoardState() {\n      return this.isGameOver;\n    }\n    static ɵfac = function BoardService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || BoardService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.UserService), i0.ɵɵinject(i3.ScoreService), i0.ɵɵinject(PLATFORM_ID));\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: BoardService,\n      factory: BoardService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return BoardService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}